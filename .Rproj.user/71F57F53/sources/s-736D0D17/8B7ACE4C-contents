---
title: "ISQA 8700 Assignment 4"
author: "Alex Daly"
date: "4/4/2022"
output:
  html_document: default
  pdf_document: default
---

# Initial Setup

First, for the assignment, I loaded the libraries I needed.

```{r setup, echo=TRUE, include=FALSE, message=FALSE, warning=FALSE, cache=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(readxl)
library(factoextra)
```

Then I converted the excel sheets into data frames.

```{r loadData, echo=TRUE}
fraudData <- read_excel("FraudRaw.xls")
loanData <- read_excel("LoanRaw.xls")
```

# Question  1

I started by taking the fraud data and cleaned it according to how the chapter described I should. After all of the data has been cleaned, I split the first 2000 rows into the training and testing sets. 

```{r fraudClean, echo=TRUE}
cleanedFraud <- fraudData
cleanedFraud$Age <- ifelse(cleanedFraud$Age<20, 0, cleanedFraud$Age)
cleanedFraud$Age <- ifelse(cleanedFraud$Age>=20 & cleanedFraud$Age<40, (cleanedFraud$Age-20)/20, cleanedFraud$Age)
cleanedFraud$Age <- ifelse(cleanedFraud$Age>=40 & cleanedFraud$Age<60, 1, cleanedFraud$Age)
cleanedFraud$Age <- ifelse(cleanedFraud$Age>=60 & cleanedFraud$Age<70, (cleanedFraud$Age-60)/10, cleanedFraud$Age)
cleanedFraud$Age <- ifelse(cleanedFraud$Age>=70, 0, cleanedFraud$Age)

cleanedFraud$Claim <- ifelse(1-cleanedFraud$Claim/5000 > 0, 1-cleanedFraud$Claim/5000, 0)

cleanedFraud$tickets[cleanedFraud$tickets == 1] = 0.6
cleanedFraud$tickets[cleanedFraud$tickets == 0] = 1
cleanedFraud$tickets[cleanedFraud$tickets >= 2] = 0

cleanedFraud$`prior claims`[cleanedFraud$`prior claims` == 1] = 0.5
cleanedFraud$`prior claims`[cleanedFraud$`prior claims` == 0] = 1
cleanedFraud$`prior claims`[cleanedFraud$`prior claims` >= 2] = 0

cleanedFraud$atty[cleanedFraud$atty != "none"] = 0
cleanedFraud$atty[cleanedFraud$atty == "none"] = 1

fraudTrainingSet <- cleanedFraud %>% filter(row(cleanedFraud) >= 1 & row(cleanedFraud) <= 1000)
fraudTestingSet <- cleanedFraud %>% filter(row(cleanedFraud) >= 1001 & row(cleanedFraud) <= 2000)
```

For my initial clusters, I used the first instances where an outcome were 0 and 1 since if I didn't specify, it would randomly choose which rows to use. These were rows 1 and 253 of the Training data set, respectively. Using those in the k-means function, I was able to calculate the clusters for the Testing data set.

```{r fraudKmeans, echo=TRUE}
fraudInitialCenters <- fraudTrainingSet[c(1, 57), ]

fraudClusters <- kmeans(x=fraudTrainingSet, centers=fraudInitialCenters, nstart = 2)
print(fraudClusters)
```

Since I could not find a function in R to apply a cluster to a Testing data set, I created my own. I pulled out the values for each cluster for easier reference. Then, I calculated the sum of squared differences from each row in the data set to each cluster and recorded the outcome along with whichever cluster was closer. I then displayed the coincidence matrix for the testing data. The model correctly identified the outcome 87.6% of the time.

```{r fraudKmeansTest, echo=TRUE}
center1Age = fraudClusters$centers[c("1"),c("Age")]
center1Gender = fraudClusters$centers[c("1"),c("Gender")]
center1Claim = fraudClusters$centers[c("1"),c("Claim")]
center1Tickets = fraudClusters$centers[c("1"),c("tickets")]
center1PriorClaims = fraudClusters$centers[c("1"),c("prior claims")]
center1Atty = fraudClusters$centers[c("1"),c("atty")]
center1Outcome = fraudClusters$centers[c("1"),c("outcome")]

center2Age = fraudClusters$centers[c("2"),c("Age")]
center2Gender = fraudClusters$centers[c("2"),c("Gender")]
center2Claim = fraudClusters$centers[c("2"),c("Claim")]
center2Tickets = fraudClusters$centers[c("2"),c("tickets")]
center2PriorClaims = fraudClusters$centers[c("2"),c("prior claims")]
center2Atty = fraudClusters$centers[c("2"),c("atty")]
center2Outcome = fraudClusters$centers[c("2"),c("outcome")]

fraudTestingSet$modelOutcome = ifelse(
  (
    (fraudTestingSet$Age-center1Age)^2+
    (fraudTestingSet$Gender-center1Gender)^2+
    (fraudTestingSet$Claim-center1Claim)^2+
    (fraudTestingSet$tickets-center1Tickets)^2+
    (fraudTestingSet$'prior claims'-center1PriorClaims)^2+
    (strtoi(fraudTestingSet$atty)-center1Atty)^2+
    (fraudTestingSet$outcome-center1Outcome)^2
  ) < (
    (fraudTestingSet$Age-center2Age)^2+
    (fraudTestingSet$Gender-center2Gender)^2+
    (fraudTestingSet$Claim-center2Claim)^2+
    (fraudTestingSet$tickets-center2Tickets)^2+
    (fraudTestingSet$'prior claims'-center2PriorClaims)^2+
    (strtoi(fraudTestingSet$atty)-center2Atty)^2+
    (fraudTestingSet$outcome-center2Outcome)^2
  ), "Model 0", "Model 1")

table(fraudTestingSet$modelOutcome, fraudTestingSet$outcome)
```

## Question 1 Analysis

In my first cluster where an insurance claim is likely ok, the age of the person is closer to 40-60, the gender split is fairly even with a slight female lean, most likely have 1 ticket with 0 prior claims, and does not have an attorney. 
In my second cluster where an insurance claim is likely fraud, the age of the person is probably very young or very old, more likely to be male, still most likely to have submitted 1 ticket, but should have 1 or more prior claims, and is more likely to have an attorney than the other cluster. 
This model is very good at predicting an insurance claim is ok but is very bad at predicting fraud. I would need more cases of fraud to use for testing and training to better predict that. The best I can say is that if the person is male and has prior claims, they should be scrutinized more for potentially being fraudulent.

# Question 4

For this questions, I started again by cleaning the data as explained by the book.

```{r loanClean, echo=TRUE}
precleanedLoan <- loanData

precleanedLoan$Age <- ifelse(precleanedLoan$Age<20, 0, precleanedLoan$Age)
precleanedLoan$Age <- ifelse(precleanedLoan$Age>=20 & precleanedLoan$Age<50, (precleanedLoan$Age-20)/30, precleanedLoan$Age)
precleanedLoan$Age <- ifelse(precleanedLoan$Age>=50 & precleanedLoan$Age<80, 1-((precleanedLoan$Age-50)/30), precleanedLoan$Age)
precleanedLoan$Age <- ifelse(precleanedLoan$Age>=70, 0, precleanedLoan$Age)

precleanedLoan$Income <- ifelse(precleanedLoan$Income < 0, 0, precleanedLoan$Income)
precleanedLoan$Income <- ifelse(precleanedLoan$Income >= 0 & precleanedLoan$Income <= 100000, precleanedLoan$Income/100000, precleanedLoan$Income)
precleanedLoan$Income <- ifelse(precleanedLoan$Income > 100000, 1, precleanedLoan$Income)

precleanedLoan$Risk <- ifelse(precleanedLoan$Assets/(precleanedLoan$Debts + precleanedLoan$Want) > 1, 1, precleanedLoan$Assets/(precleanedLoan$Debts + precleanedLoan$Want))

precleanedLoan <- transform(precleanedLoan, credit = factor(credit,
          levels = c("green", "amber", "red"),
          labels = c(1, 0.3, 0)))

cleanedLoan <- select(precleanedLoan, c('Age', 'Income', 'Risk', 'credit', 'On.time'))
```

To set my initial clusters, I again chose instances where On-time was 0 and 1. These were rows 9 and 1, respectively.

```{r loanKmeans, echo=TRUE}
loanInitialCenters <- cleanedLoan[c(9, 1), ]

loanClusters <- kmeans(x=cleanedLoan, centers=loanInitialCenters, nstart = 2)
print(loanClusters)
```

## Question 4 Analysis

I had two clusters. The first cluster is where people were not on-time for paying their loans. They have a lower credit rating, more risk as their assets are smaller compared to their debt and wants, and a lower income. They are usually ages 45-55.
The second cluster is where people were paying their loans on-time. They have better credit rating, less risk as their assets are larger compared to their debt and wants, and a higher income. They are usually ages 27-73, a much wider range than the first cluster.
With this model, it modeled the data set at 100% success. I would need to do some testing to make sure the model is working, but from the model, people who are on-time for paying their loans have a higher credit rating, less risk, and more income. This means that they have had a previous history of paying on time and are more likely to borrow within their means and pay it back. 

```{r loanMatrix, echo=TRUE}
table(loanClusters$cluster, cleanedLoan$On.time)
```